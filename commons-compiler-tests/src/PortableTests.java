
/*
 * Janino - An embedded Java[TM] compiler
 *
 * Copyright (c) 2001-2010, Arno Unkrig
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of conditions and the
 *       following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *       following disclaimer in the documentation and/or other materials provided with the distribution.
 *    3. The name of the author may not be used to endorse or promote products derived from this software without
 *       specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import org.codehaus.commons.compiler.CompilerFactoryFactory;
import org.codehaus.commons.compiler.ICompilerFactory;
import org.codehaus.commons.compiler.IExpressionEvaluator;
import org.codehaus.commons.compiler.ISimpleCompiler;

import util.JaninoTestSuite;

import junit.framework.TestCase;

public class PortableTests extends JaninoTestSuite {

    public PortableTests(ICompilerFactory compilerFactory) throws Exception {
        super("Suite of all portable tests", compilerFactory);

        this.addTest(EvaluatorTests.suite(compilerFactory));
        this.addTest(new JLS2Tests(compilerFactory));
//        this.addTest(new MultiThreadedIssueTest(compilerFactory));
        this.addTest(JavaSourceClassLoaderTests.suite(compilerFactory));
        this.addTest(new ReportedBugs(compilerFactory));
        this.addTest(SandboxTests.suite(compilerFactory));
        this.addTest(SerializationTests.suite(compilerFactory));

        section(1, ISimpleCompiler.class.getName());

        section(2, "Default imports");
        exp(TRUE, "1", (
            "new ArrayList().getClass().getName().equals(\"java.util.ArrayList\")"
        )).setDefaultImports(new String[] { "java.util.*" });
        scr(SCAN, "2", "xxx").setDefaultImports(new String[] { "java.util#" });
        scr(PARS, "3", "xxx").setDefaultImports(new String[] { "java.util.9" });
        scr(PARS, "4", "xxx").setDefaultImports(new String[] { "java.util.*;" });
        clb(TRUE, "5", (
            "public static boolean main() { return new ArrayList() instanceof List; }"
        )).setDefaultImports(new String[] { "java.util.*" });
        exp(COMP, "6", "new ArrayList()").setDefaultImports(new String[] { "java.io.*" });

        section(2, "Equals");
        this.addTest(new TestCase("1") {
            protected void runTest() throws Exception {

                // Parameters have different names in ee2 and one unnecessary cast, but the generated bytecode is
                // identical.
                IExpressionEvaluator ee1 = CompilerFactoryFactory.getDefaultCompilerFactory().newExpressionEvaluator();
                ee1.setExpressionType(double.class);
                ee1.setParameters(new String[] { "a", "b" }, new Class[] { int.class, double.class });
                ee1.cook("a + b");

                IExpressionEvaluator ee2 = CompilerFactoryFactory.getDefaultCompilerFactory().newExpressionEvaluator();
                ee2.setExpressionType(double.class);
                ee2.setParameters(new String[] { "c", "d" }, new Class[] { int.class, double.class });
                ee2.cook("(double) c + d");

                assertEquals("SimpleCompiler equality", ee1, ee2);
            }
        });
        this.addTest(new TestCase("2") {
            protected void runTest() throws Exception {

                // In ee2, the sum operands swapped, resulting in slightly different byte code.
                IExpressionEvaluator ee1 = CompilerFactoryFactory.getDefaultCompilerFactory().newExpressionEvaluator();
                ee1.setExpressionType(double.class);
                ee1.setParameters(new String[] { "a", "b" }, new Class[] { int.class, double.class });
                ee1.cook("a + b");

                IExpressionEvaluator ee2 = CompilerFactoryFactory.getDefaultCompilerFactory().newExpressionEvaluator();
                ee2.setExpressionType(double.class);
                ee2.setParameters(new String[] { "a", "b" }, new Class[] { int.class, double.class });
                ee2.cook("b + a");

                assertFalse("SimpleCompiler equality", ee1.equals(ee2));
            }
        });

        section(null);
    }
}
