{
  "name": "Janino",
  "tagline": "A super-small, super-fast Java™ compiler",
  "body": "![Janino Swoosh](https://github.com/janino-compiler/janino/blob/master/janino-dist/logo/logo_167x134.gif)\r\n\r\nJanino can not only\r\n[compile a set of source files to a set of class files like JAVAC](#janino-as-a-command-line-java-compiler),\r\nbut also\r\n[compile a Java™ expression](#janino-as-an-expression-evaluator),\r\n[block](#janino-as-a-script-evaluator),\r\n[class body](#janino-as-a-class-body-evaluator)\r\nor\r\n[source file](#janino-as-a-simple-compiler)\r\nin memory, load the bytecode and execute it directly in the same JVM.\r\n\r\nJANINO is integrated with Apache Commons JCI (\"Java Compiler Interface\") and JBoss Rules / Drools.\r\n\r\nJANINO can also be used for static code analysis or code manipulation.\r\n\r\nJANINO can be configured to use javax.tools.JavaCompiler, i.e. JAVAC, which removes the Java 5-related limitations.\r\n\r\n## Properties\r\n\r\nThe major design goal was to keep the compiler small and simple, while providing an (almost) complete Java&trade; compiler.\r\n\r\nThe following elements of the Java programming language are implemented:\r\n\r\n* <tt>package declaration</tt>, <tt>import</tt> declaration\r\n* <tt>class</tt> declaration, <tt>interface</tt> declaration\r\n* Inheritance (<tt>extends</tt> and <tt>implements</tt>)\r\n* Static member type declaration\r\n* Inner (non-static member, local, anonymous) class declaration\r\n* Class initializer, instance initializer\r\n* Field declaration, method declaration\r\n* Local variable declaration\r\n* Class variable initializer, instance variable initializer\r\n* Block statement (<tt>{...}</tt>)\r\n* <tt>if ... else</tt> statement\r\n* Basic <tt>for</tt> statement\r\n* Enhanced <tt>for</tt> statement\r\n* <tt>while</tt> statement\r\n* <tt>do ... while</tt> statement\r\n* <tt>try ... catch ... finall</tt>y statement\r\n* <tt>throw</tt> statement\r\n* <tt>return</tt> statement\r\n* <tt>break</tt> statement\r\n* <tt>continue</tt> statement\r\n* <tt>switch</tt> statement\r\n* <tt>synchronized</tt> statement\r\n* All primitive types (<tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt>, <tt>long</tt>, <tt>float</tt>, <tt>double</tt>)\r\n* Assignment operator <tt>=</tt>\r\n* Compound assignment operators <tt>+=</tt>, <tt>-=</tt>, <tt>*=</tt>, <tt>/=</tt>, <tt>&=</tt>, <tt>|=</tt>, <tt>^=</tt>, <tt>%=</tt>, <tt><<=</tt>, <tt>>>=</tt>, <tt>>>>=</tt>\r\n* Conditional operators <tt>? ... :</tt>, <tt>&&</tt>, <tt>||</tt>\r\n* Boolean logical operators <tt>&</tt>, <tt>^</tt>, <tt>|</tt>\r\n* Integer bitwise operators <tt>&</tt>, <tt>^</tt>, <tt>|</tt>\r\n* Numeric operators <tt>*</tt>, <tt>/</tt>, <tt>%</tt>, <tt>+</tt>, <tt>-</tt>, <tt><<</tt>, <tt>>></tt>, <tt>>>></tt>\r\n* String concatenation operator <tt>+</tt>\r\n* Operators <tt>++</tt> and <tt>--</tt>\r\n* Type comparison operator <tt>instanceof</tt>\r\n* Unary operators <tt>+</tt>, <tt>-</tt>, <tt>~</tt>, <tt>!</tt>\r\n* Parenthesized expression\r\n* Field access (like <tt>System.out</tt>)\r\n* Superclass member access (<tt>super.meth()</tt>, <tt>super.field</tt>)\r\n* <tt>this</tt> (reference to current instance)\r\n* Alternate constructor invocation (<tt>this(a, b, c);</tt>)\r\n* Superclass constructor invocation (<tt>super(a, b, c);</tt>)\r\n* Method invocation (<tt>System.out.println(\"Hello\")</tt>)\r\n* Class instance creation (<tt>new Foo()</tt>)\r\n* Primitive array creation (<tt>new int[10][5][]</tt>)\r\n* Class or interface array creation (<tt>new Foo[10][5][]</tt>)\r\n* Array access (<tt>args[0]</tt>)\r\n* Local variable access\r\n* Integer, floating-point, boolean, character, string literal\r\n* <tt>null</tt> literal\r\n* Unary numeric conversion, binary numeric conversion, widening numeric conversion, narrowing numeric conversion, widening reference conversion, narrowing reference conversion\r\n* Cast\r\n* Assignment conversion\r\n* String conversion (for string concatenation)\r\n* Constant expression\r\n* Block scope, method scope, class scope, global scope\r\n* <tt>throws</tt> clause\r\n* Array initializer (<tt>String[] a = { \"x\", \"y\", \"z\" }</tt>)\r\n* Primitive class literals (<tt>int.class</tt>)\r\n* Non-primitive class literals (<tt>String.class</tt>)\r\n* References between uncompiled compilation units\r\n* Line number tables (\"<tt>-g:lines</tt>\")\r\n* Source file information (\"<tt>-g:source</tt>\")\r\n* Local variable information information (\"<tt>-g:vars</tt>\")\r\n* Handling of <tt>@deprecated</tt> doc comment tag\r\n* Accessibility checking (<tt>public</tt>, <tt>protected</tt>, <tt>private</tt>)\r\n* Checking of \"definite assignment\" (JLS7 16)\r\n* Methods that compile to more than 32 KB\r\n* <tt>assert</tt> (partial: assertions are always enabled, as if \"<tt>-ea</tt>\" were given)\r\n* Static imports (single and on-demand; fields, types and methods)\r\n* Autoboxing and unboxing\r\n* <tt>StringBuilder</tt> class used for string concatenation\r\n* Covariant return types\r\n* Annotations (partial: Not yet stored into the CLASS file)\r\n* <tt>@Override</tt> annotation\r\n* Variable arity methods (a.k.a. \"varargs\")\r\n* Type arguments (<tt>List<String></tt>) are parsed, but otherwise ignored\r\n\r\n## Limitations\r\n\r\nThe following elements of the Java programming language are not implemented:\r\n\r\n* Declaration of parametrized types (type arguments, however, are (partially) implemented, see above)\r\n* Typesafe enums\r\n* Annotation declarations (annotation uses, however, are (partially) implemented, see above)\r\n\r\n## Download\r\n\r\n### Packages\r\n\r\nIf you are using MAVEN, add this entry to your POM file:\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.codehaus.janino</groupId>\r\n    <artifactId>janino</artifactId>\r\n    <version>2.7.5</version>\r\n</dependency>\r\n```\r\n\r\n(Replace '2.7.5' with the very latest version of JANINO.)\r\n\r\nIf you are not using MAVEN, do the following instead:\r\n\r\n* Download the latest distribution of Janino from the [download page](http://janino.unkrig.de/download/).\r\n* Unzip the distribution file you have downloaded:\r\n\r\n```shell\r\n$ jar xvf janino-*.zip\r\n```\r\n\r\n* Change to the Janino directory:\r\n\r\n```shell\r\n$ cd janino-*\r\n```\r\n\r\n* You will find the Janino JAR files, the source code ZIP files, the text of the BSD license, and a README file.\r\n\r\n* Put \"commons-compiler.jar\" and \"janino.jar\" on your class path.\r\n\r\n### Installation\r\n\r\nIf you're using an IDE like ECLIPSE, you can optionally have \"commons-compiler-src.zip\" as the source attachment of \"commons-compiler.jar\", and \"janino-src.zip\" as the source attachment of \"janino.jar\". That'll get you tooltip JAVADOC and source level debugging into the JANINO libraries.\r\n\r\nUse one of the features, e.g. the \"expression evaluator\", in your program:\r\n\r\n```java\r\nimport org.codehaus.janino.*;\r\n\r\nExpressionEvaluator ee = new ExpressionEvaluator();\r\nee.cook(\"3 + 4\");\r\nSystem.out.println(ee.evaluate(null));\r\n```\r\n\r\nCompile, run, ... be happy!\r\n\r\n### Examples\r\n\r\nThe ShippingCost class demonstrates how easy it is to use Janino as an expression evaluator.\r\n\r\nThe ExpressionDemo class implements a command line-based test environment for the expression evaluator.\r\n\r\nThe ScriptDemo class implements a command line-based test environment for the script evaluator.\r\n\r\nThe ClassBodyDemo class implements a command line-based test environment for the class body evaluator.\r\n\r\nThe DeclarationCounter class implements a command-line utility that counts class, interface, field and local variable declarations in a set of Java&trade; source files.\r\n\r\n## Documentation\r\n\r\n### JAVADOC\r\n\r\nThe full JAVADOC documentation for JANINO is available [online](http://janino.unkrig.de/javadoc/index.html).\r\n\r\n### Books\r\n\r\nThe specifications of the Java programming language:\r\n\r\n* James Gosling, Bill Joy, Guy Steele, Gilad Bracha, Alex Buckley: The Java Language Specification, Java SE 7 Edition; Oracle America, Inc., 2011\r\n\r\n* Tim Lindholm, Frank Yellin, Gilad Bracha, Alex Buckley: The Java Virtual Machine Specification, Java SE 7 Edition; Oracle America, Inc., 2011\r\n\r\nBooks that refer to the JANINO technology:\r\n\r\n* Friedrich Esser: Java 6 Core Techniken: Essentielle Techniken für Java-Apps; Oldenbourg, 2008\r\n\r\n* Lars Wunderlich: Java Rules Engines. Entwicklung von regelbasierten Systemen; Entwickler.Press, 2006\r\n\r\n* Lars Wunderlich: AOP-Aspektorientierte Programmierung in der Praxis. Konzepte und ihre Realisierung in Java; Entwickler.Press, 2005\r\n\r\n### Links\r\n\r\n#### Articles about JANINO\r\n\r\n* Andrew Davison's Chapter [\"JavaArt. On-the-Fly Dynamic Compilation and Execution\"](http://fivedots.coe.psu.ac.th/~ad/jg/javaArt1/) from his book \"Killer Game Programming in Java\".\r\n\r\n* Tom Gibara's excellent article on his [\"String Concatenation Benchmark\"](http://www.tomgibara.com/janino-evaluation/string-concatenation-benchmark).\r\n\r\n#### Some open source projects that use JANINO\r\n\r\n* [Logback](http://logback.qos.ch/) - a Java&trade; logging framework intended as a successor to the LOG4J project\r\n\r\n* [Optiq](https://github.com/julianhyde/optiq/) – A dynamic data management framework which is used by Apache Hive and Apache Drill\r\n\r\n* [Virgo](https://projects.eclipse.org/projects/rt.virgo) – the Java application server from [Eclipse RT](http://www.eclipse.org/rt/)\r\n\r\n* [Carbon](http://wso2.com/products/carbon/) – the OSGi middleware platform of WSO2\r\n\r\n* [Groovy](http://groovy-lang.org/) – an agile dynamic language for the JVM combining lots of great features from languages like Python, Ruby and Smalltalk and making them available to the Java developers using a Java-like syntax.\r\n\r\n* [Red Hat JBoss BRMS](http://www.jboss.org/products/brms/overview/) – JBoss's business rules management system\r\n\r\n* The [JAITools](http://jaitools.org/) (\"Java Advanced Imaging\") library includes [JIFFLE](http://jaitools.org/docs/jiffle/latest/userguide/html/), an image scripting language, that is compiled with JANINO.\r\n\r\n* [JINX](http://jinx00.sourceforge.net/) – Java multi-user unix-like system.\r\n\r\n* [Farrago](http://farrago.sourceforge.net/) – an extensible RDBMS framework with a hybrid Java/C++/UML architecture.\r\n\r\n* [Scripteffect](http://jvaptools.sourceforge.net/scripteffect.html) – a Java VST audio plugin that enables audio developers or musicans to run Java code directly in their favorite audio VST host.\r\n\r\n* [Deimos](http://deimosproject.sourceforge.net/) – a Java-based 3D space combat game.\r\n\r\n#### Other Java&trade; compiler projects and products that I know about\r\n\r\n* [Embarcadero JBuilder](http://www.embarcadero.com/products/jbuilder)\r\n\r\n* [gcj](https://gcc.gnu.org/java/) – the GNU Compiler for Java&trade;\r\n\r\n* [javac](http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html) – the Java&trade; compiler from ORACLE&trade;\r\n\r\n* [jikes – IBM's Java&trade; compiler](http://jikes.sourceforge.net/)\r\n\r\n* [The Kopi Java&trade; Compiler](http://cs.gmu.edu/~eclab/projects/robots/flockbots/uploads/Main/kopi.html)\r\n\r\n* [Pizza](http://pizzacompiler.sourceforge.net/)\r\n\r\n* [Espresso](http://types.bu.edu/Espresso/JavaEspresso.html)\r\n\r\n### Basic Examples\r\n\r\n#### Janino as an Expression Evaluator\r\n\r\nSay you build an e-commerce system, which computes the shipping cost for the items that the user put into his/her shopping cart. Because you don't know the merchant's shipping cost model at implementation time, you could implement a set of shipping cost models that come to mind (flat charge, by weight, by number of items, ...) and select one of those at run-time.\r\n\r\nIn practice, you will most certainly find that the shipping cost models you implemented will rarely match what the merchant wants, so you must add custom models, which are merchant-specific. If the merchant's model changes later, you must change your code, re-compile and re-distribute your software.\r\n\r\nBecause this is so unflexible, the shipping cost expression should be specified at run-time, not at compile-time. This implies that the expression must be scanned, parsed and evaluated at run-time, which is why you need an expression evaluator.\r\n\r\nA simple expression evaluator would parse an expression and create a \"syntax tree\". The expression \"a + b * c\", for example, would compile into a \"Sum\" object who's first operand is parameter \"a\" and who's second operand is a \"Product\" object who's operands are parameters \"b\" and \"c\". Such a syntax tree can evaluated relatively quickly. However, the run-time performance is about a factor of 100 worse than that of \"native\" Java&trade; code executed directly by the JVM. This limits the use of such an expression evaluator to simple applications.\r\n\r\nAlso, you may want not only do simple arithmetics like \"a + b * c % d\", but take the concept further and have a real \"scripting\" language which adds flexibility to your application. Since you know the Java&trade; programming language already, you may want to have a syntax that is similar to that of the Java&trade; programming language.\r\n\r\nAll these considerations lead to compilation of Java&trade; code at run-time, like some engines (e.g. JSP engines) already do. However, compiling Java&trade; programs with ORACLE's JDK is a relatively resource-intensive process (disk access, CPU time, ...). This is where Janino comes into play... a light-weight, \"embedded\" Java&trade; compiler that compiles simple programs in memory into Java&trade; bytecode which executes within the JVM of the running program.\r\n\r\nOK, now you are curious... this is how you use the ExpressionEvaluator:\r\n\r\n```java\r\npackage foo;\r\n\r\nimport java.lang.reflect.InvocationTargetException;\r\n\r\nimport org.codehaus.commons.compiler.CompileException;\r\nimport org.codehaus.janino.ExpressionEvaluator;\r\n\r\npublic class Main {\r\n\r\n    public static void\r\n    main(String[] args) throws CompileException, InvocationTargetException {\r\n\r\n        // Now here's where the story begins...\r\n        ExpressionEvaluator ee = new ExpressionEvaluator();\r\n\r\n        // The expression will have two \"int\" parameters: \"a\" and \"b\".\r\n        ee.setParameters(new String[] { \"a\", \"b\" }, new Class[] { int.class, int.class });\r\n\r\n        // And the expression (i.e. \"result\") type is also \"int\".\r\n        ee.setExpressionType(int.class);\r\n\r\n        // And now we \"cook\" (scan, parse, compile and load) the fabulous expression.\r\n        ee.cook(\"a + b\");\r\n\r\n        // Eventually we evaluate the expression - and that goes super-fast.\r\n        int result = (Integer) ee.evaluate(new Object[] { 19, 23 });\r\n        System.out.println(result);\r\n    }\r\n}\r\n```\r\n\r\nNotice: If you pass a string literal as the expression, be sure to escape all Java&trade; special characters, especially backslashes.\r\n\r\nThe compilation of the expression takes 670 microseconds on my machine (2 GHz P4), and the evaluation 0.35 microseconds (approx. 2000 times faster than compilation).\r\n\r\nThere is a sample program \"ExpressionDemo\" that you can use to play around with the ExpressionEvaluator, or you can study [ExpressionDemo's source code](http://janino.unkrig.de/samples/ExpressionDemo.java) to learn about ExpressionEvaluator's API:\r\n\r\n```shell\r\n$ java -cp janino.jar:commons-compiler.jar \\\r\n> org.codehaus.commons.compiler.samples.ExpressionDemo \\\r\n> -help\r\nUsage:\r\n  ExpressionDemo { <option> } <expression> { <parameter-value> }\r\nCompiles and evaluates the given expression and prints its value.\r\nValid options are\r\n -et <expression-type>                        (default: any)\r\n -pn <comma-separated-parameter-names>        (default: none)\r\n -pt <comma-separated-parameter-types>        (default: none)\r\n -te <comma-separated-thrown-exception-types> (default: none)\r\n -di <comma-separated-default-imports>        (default: none)\r\n -help\r\nThe number of parameter names, types and values must be identical.\r\n$ java -cp janino.jar:commons-compiler.jar \\\r\n> org.codehaus.commons.compiler.samples.ExpressionDemo \\\r\n> -et double \\\r\n> -pn x \\\r\n> -pt double \\\r\n> \"Math.sqrt(x)\" \\\r\n> 99\r\nResult = 9.9498743710662\r\n$\r\n```\r\n\r\n#### Janino as a Script Evaluator\r\n\r\nAnalogously to the expression evaluator, a ScriptEvaluator API exists that compiles and processes a Java&trade; \"block\", i.e. the body of a method. If a return value other than \"void\" is defined, then the block must return a value of that type.\r\n\r\nAs a special feature, it allows methods to be declared. The place and order of the method declarations is not relevant.\r\n\r\nExample:\r\n\r\n```java\r\npackage foo;\r\n\r\nimport java.lang.reflect.InvocationTargetException;\r\n\r\nimport org.codehaus.commons.compiler.CompileException;\r\nimport org.codehaus.janino.ScriptEvaluator;\r\n\r\npublic class Main {\r\n\r\n    public static void\r\n    main(String[] args) throws CompileException, NumberFormatException, InvocationTargetException {\r\n\r\n        ScriptEvaluator se = new ScriptEvaluator();\r\n\r\n        se.cook(\r\n            \"\"\r\n            + \"static void method1() {\\n\"\r\n            + \"    System.out.println(1);\\n\"\r\n            + \"}\\n\"\r\n            + \"\\n\"\r\n            + \"method1();\\n\"\r\n            + \"method2();\\n\"\r\n            + \"\\n\"\r\n            + \"static void method2() {\\n\"\r\n            + \"    System.out.println(2);\\n\"\r\n            + \"}\\n\"\r\n        );\r\n\r\n        se.evaluate(new Object[0]);\r\n    }\r\n}\r\n```\r\n\r\nAs for the expression compiler, there is a demo program \"ScriptDemo\" for you to play with the ScriptEvaluator API:\r\n\r\n```shell\r\n$ java -cp janino.jar:commons-compiler.jar \\\r\n> org.codehaus.commons.compiler.samples.ScriptDemo -help\r\nUsage:\r\n  ScriptDemo { <option> } <script> { <parameter-value> }\r\nValid options are\r\n -rt <return-type>                            (default: void)\r\n -pn <comma-separated-parameter-names>        (default: none)\r\n -pt <comma-separated-parameter-types>        (default: none)\r\n -te <comma-separated-thrown-exception-types> (default: none)\r\n -di <comma-separated-default-imports>        (default: none)\r\n -help\r\nThe number of parameter names, types and values must be identical.\r\n$ java -cp janino.jar:commons-compiler.jar \\\r\n> org.codehaus.commons.compiler.samples.ScriptDemo '\r\n> for (int i = 0; i < 3; i++) {\r\n>     System.out.println(\"HELLO\");\r\n> }'\r\nHELLO\r\nHELLO\r\nHELLO\r\nResult = (null)\r\n$\r\n```\r\n\r\nCheck [the source code of ScriptDemo](http://janino.unkrig.de/samples/ScriptDemo.java) to learn more about the ScriptEvaluator API.\r\n\r\n#### Janino as a Class Body Evaluator\r\n\r\nAnalogously to the expression evaluator and the script evaluator, a ClassBodyEvaluator exists that compiles and processes the body of a Java&trade; class, i.e. a series of method and variable declarations. If you define a contract that the class body should define a method named \"main()\", then your script will look almost like a \"C\" program:\r\n\r\n```java\r\npublic static void\r\nmain(String[] args) {\r\n    System.out.println(java.util.Arrays.asList(args));\r\n}\r\n```\r\n\r\nThe \"ClassBodyDemo\" program (source code) demonstrates this:\r\n\r\n```shell\r\n$ java -cp janino.jar:commons-compiler.jar \\\r\n> org.codehaus.commons.compiler.samples.ClassBodyDemo -help\r\nUsage:\r\n  ClassBodyDemo <class-body> { <argument> }\r\n  ClassBodyDemo -help\r\nIf <class-body> starts with a '@', then the class body is read\r\nfrom the named file.\r\nThe <class-body> must declare a method \"public static void main(String[])\"\r\nto which the <argument>s are passed. If the return type of that method is\r\nnot VOID, then the returned value is printed to STDOUT.\r\n$ java -cp janino.jar:commons-compiler.jar \\\r\n> org.codehaus.commons.compiler.samples.ClassBodyDemo '\r\n> public static void\r\n> main(String[] args) {\r\n>     System.out.println(java.util.Arrays.asList(args));\r\n> }' \\\r\n> a b c\r\n[a, b, c]\r\n$\r\n```\r\n\r\n#### Janino as a Simple Compiler\r\n\r\nThe SimpleCompiler compiles a single \"compilation unit\" (a.k.a. \".java\" file). Opposed to to normal Java&trade; compilation, that compilation unit may define more than one public class. Example:\r\n\r\n```java\r\n// This is file \"Hello.java\", but it could have any name.\r\n\r\npublic\r\nclass Foo {\r\n   \r\n    public static void\r\n    main(String[] args) {\r\n        new Bar().meth();\r\n    }\r\n}\r\n\r\npublic\r\nclass Bar {\r\n   \r\n    public void\r\n    meth() {\r\n        System.out.println(\"HELLO!\");\r\n    }\r\n}\r\n```\r\n\r\nIt returns a ClassLoader from which you can retrieve the classes that were compiled.\r\n\r\nTo run this, type:\r\n\r\n```shell\r\n$ java -cp janino.jar:commons-compiler.jar \\\r\n> org.codehaus.janino.SimpleCompiler -help\r\nUsage:\r\n    org.codehaus.janino.SimpleCompiler <source-file> <class-name> { <argument> }\r\nReads a compilation unit from the given <source-file> and invokes method\r\n\"public static void main(String[])\" of class <class-name>, passing the\r\ngiven <argument>s.\r\n$ java -cp janino.jar:commons-compiler.jar \\\r\n> org.codehaus.janino.SimpleCompiler \\\r\n> Hello.java Foo\r\nHELLO!\r\n$\r\n```\r\n\r\n### Advanced Examples\r\n\r\n#### Janino as a Source Code ClassLoader\r\n\r\nThe JavaSourceClassLoader extends Java&trade;'s java.lang.ClassLoader class with the ability to load classes directly from source code.\r\n\r\nTo be precise, if a class is loaded through this ClassLoader, it searches for a matching \".java\" file in any of the directories specified by a given \"source path\", reads, scans, parses and compiles it and defines the resulting classes in the JVM. As necessary, more classes are loaded through the parent class loader and/or through the source path. No intermediate files are created in the file system.\r\n\r\nExample:\r\n\r\n```java\r\n// srcdir/pkg1/A.java\r\n\r\npackage pkg1;\r\n\r\nimport pkg2.*;\r\n\r\npublic class A extends B {\r\n}\r\n```\r\n\r\n```java\r\n// srcdir/pkg2/B.java\r\n\r\npackage pkg2;\r\n\r\npublic class B implements Runnable {\r\n    public void run() {\r\n        System.out.println(\"HELLO\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n// Sample code that reads, scans, parses, compiles and loads\r\n// \"A.java\" and \"B.java\", then instantiates an object of class\r\n// \"A\" and invokes its \"run()\" method.\r\nClassLoader cl = new JavaSourceClassLoader(\r\n    this.getClass().getClassLoader(),  // parentClassLoader\r\n    new File[] { new File(\"srcdir\") }, // optionalSourcePath\r\n    (String) null,                     // optionalCharacterEncoding\r\n    DebuggingInformation.NONE          // debuggingInformation\r\n);\r\n\r\n// Load class A from \"srcdir/pkg1/A.java\", and also its superclass\r\n// B from \"srcdir/pkg2/B.java\":\r\nObject o = cl.loadClass(\"pkg1.A\").newInstance();\r\n\r\n// Class \"B\" implements \"Runnable\", so we can cast \"o\" to\r\n// \"Runnable\".\r\n((Runnable) o).run(); // Prints \"HELLO\" to \"System.out\".\r\n```\r\n\r\nIf the Java&trade; source is not available in files, but from some other storage (database, main memory, ...), you may specify a custom ResourceFinder instead of the directory-based source path.\r\n\r\nIf you have many source files and you want to reduce the compilation time, you may want to use the CachingJavaSourceClassLoader, which uses a cache provided by the application to store class files for repeated use.\r\n\r\nA BASH shell script named \"bin/janino\" is provided that wraps the JavaSourceClassLoader in a JAVAC-like command line interface:\r\n\r\n```shell\r\n$ cat my/pkg/A.java\r\npackage my.pkg;\r\n\r\nimport java.util.*;\r\n\r\npublic class A {\r\n    public static void main(String[] args) {\r\n        B b = new B();\r\n        b.meth1();\r\n    }\r\n}\r\n\r\nclass B {\r\n    void meth1() {\r\n        System.out.println(\"Hello there.\");\r\n    }\r\n}\r\n$ type janino\r\n/usr/local/bin/janino\r\n$ janino my.pkg.A\r\nHello there.\r\n$\r\n```\r\n\r\n#### Janino as a Command-Line Java&trade; Compiler\r\n\r\nThe Compiler class mimics the behavior of ORACLE's javac tool. It compiles a set of \"compilation units\" (i.e. Java&trade; source files) into a set of class files.\r\n\r\nUsing the \"-warn\" option, Janino emits some probably very interesting warnings which may help you to \"clean up\" the source code.\r\n\r\nThe BASH script \"bin/janinoc\" implements a drop-in replacement for ORACLE's JAVAC utility:\r\n\r\n```shell\r\n$ janinoc -sourcepath src -d classes src/com/acme/MyClass.java\r\n$ janinoc -help\r\nA drop-in replacement for the JAVAC compiler, see the documentation for JAVAC\r\nUsage:\r\n  janinoc [ <option> ] ... <class-name> [ <argument> ] ...\r\nOptions:\r\n  -sourcepath <dir-list>    Where to look for source files\r\n  -classpath <dir-list>     Where to look for class files\r\n  -cp <dir-list>            Synonym for \"-classpath\"\r\n  -extdirs <dir-list>       Where to look for extension class files\r\n  -bootclasspath <dir-list> Where to look for boot class files\r\n  -encoding <encoding>      Encoding of source files, default is platform-dependent\r\n  -verbose                  Report about opening, parsing, compiling of files\r\n  -g                        Generate all debugging info\r\n  -g:none                   Generate no debugging info\r\n  -g:{lines,vars,source}    Generate only some debugging info\r\n  -warn:<pattern-list>      Issue certain warnings, examples:\r\n    -warn:*                 Enables all warnings\r\n    -warn:IASF              Only warn against implicit access to static fields\r\n    -warn:*-IASF            Enables all warnings, except those against implicit\r\n                            access to static fields\r\n    -warn:*-IA*+IASF        Enables all warnings, except those against implicit\r\n                            accesses, but do warn against implicit access to\r\n                            static fields\r\n  -rebuild                  Compile all source files, even if the class files\r\n                            seems up-to-date\r\n  -n                        Print subcommands to STDOUT instead of running them\r\n  (any valid command-line optipon for the JAVA tool, see \"java -help\")\r\n$\r\n```\r\n\r\n#### Janino as an ANT Compiler\r\n\r\nYou can plug JANINO into the ANT utility through the AntCompilerAdapter class. Just make sure that janino.jar is on the class path, then run ANT with the following command-line option:\r\n\r\n```shell\r\n-Dbuild.compiler=org.codehaus.janino.AntCompilerAdapter\r\n```\r\n\r\n#### Janino as a TOMCAT Compiler\r\n\r\nIf you want to use JANINO with TOMCAT, just copy the \"janino.jar\" file into TOMCAT's \"common/lib\" directory, and add the follwing init parameter section to the JSP servlet definition in TOMCAT's \"conf/web.xml\" file:\r\n\r\n```xml\r\n<init-param>\r\n    <param-name>compiler</param-name>\r\n    <param-value>org.codehaus.janino.AntCompilerAdapter</param-value>\r\n</init-param>\r\n```\r\n\r\n#### Janino as a Code Analyser\r\n\r\nApart from compiling Java&trade; code, JANINO can be used for static code analysis: Based on the AST (\"abstract syntax tree\") produced by the parser, the Traverser walks through all nodes of the AST, and derived classes can do all kinds of analyses on them, e.g. count declarations:\r\n\r\n```shell\r\n$ java org.codehaus.janino.samples.DeclarationCounter DeclarationCounter.java\r\nClass declarations:     1\r\nInterface declarations: 0\r\nFields:                 4\r\nLocal variables:        4\r\n$\r\n```\r\n\r\nThis is the basis for all these neat code metrics and style checking.\r\n\r\n#### Janino as a Code Manipulator\r\n\r\nIf, e.g., you want to read a Java&trade; compilation unit into memory, manipulate it, and then write it back to a file for compilation, then all you have to do is:\r\n\r\n```java\r\n// Read the compilation unit from Reader \"r\" into memory.\r\nJava.CompilationUnit cu = new Parser(new Scanner(fileName, r)).parseCompilationUnit();\r\n\r\n// Manipulate the AST in memory.\r\n// ...\r\n\r\n// Convert the AST back into text.\r\nUnparseVisitor.unparse(cu, new OutputStreamWriter(System.out));\r\n```\r\n\r\nThe UnparseVisitor class demostrates how to do this.\r\n\r\n#### Alternative Compiler Implementations\r\n\r\nJANINO can be configured to use not its own Java™ compiler, but an alternative implementation. Alternative implementations must basically implement the interface ICompilerFactory. One such alternative implementation is based on the javax.tools API, and is shipped as part of the JANINO distribution: commons-compiler-jdk.jar.\r\n\r\nBasically there are two ways to switch implementations:\r\n\r\n* Use org.codehaus.commons.compiler.jdk.ExpressionEvaluator and consorts instead of org.codehaus.janino.ExpressionEvaluator; put commons-compiler-jdk.jar instead of janino.jar on your compile-time and runtime classpath. (commons-compiler.jar must always be on the classpath, because it contains the basic classes that every implementation requires.)\r\n\r\n* Use org.codehaus.commons.compiler.CompilerFactoryFactory.getDefaultFactory().newExpressionEvaluator() and compile only against commons-compiler.jar (and no concrete implementation). At runtime, add one implementation (janino.jar or commons-compiler-jdk.jar) to the class path, and getDefaultFactory() will find it at runtime.\r\n\r\n### Security\r\n\r\nBecause JANINO has full access to the JRE, security problems can arise if the expression, script, class body or compilation being compiled and executed contains user input.\r\n\r\nIf that user is an educated system administrator, he or she can be expected to use JANINO responsibly and in accordance with documentation and caveats you provide; however if the user is an intranet or internet user, no assumtions should be made about how clumsy, frivolous, creative, single-minded or even malicious he or she could be.\r\n\r\nThe best you can attempt is to lock the user, or, more precise, the classes generated from his or her input, in a \"sandbox\" to prevent the worst. This approach is similar to the concept of reducing the permissions of Java applets in a browser to, e.g., access files on the local file system.\r\n\r\nThis can be achieved as follows:\r\n\r\n```java\r\nimport java.security.Permissions;\r\nimport java.util.PropertyPermission;\r\nimport org.codehaus.janino.ScriptEvaluator;\r\nimport de.unkrig.commons.lang.security.Sandbox;\r\n\r\npublic class SandboxDemo {\r\n\r\n    public static void\r\n    main(String[] args) throws Exception {\r\n\r\n        // Create a JANINO script evaluator. The example, however, will work as fine with ExpressionEvaluators,\r\n        // ClassBodyEvaluators and SimpleCompilers - or with any class you do not trust, e.g. a third-party\r\n        // library.\r\n        ScriptEvaluator se = new ScriptEvaluator();\r\n\r\n        // Compile a simple script which reads two system variables - 'foo' and 'bar'.\r\n        se.cook(\r\n            \"System.getProperty(\\\"foo\\\");\\n\" +\r\n            \"System.getProperty(\\\"bar\\\");\\n\"\r\n        );\r\n\r\n        // Now we create a 'Permissions' object which allows to read the system variable 'foo', and forbids\r\n        // everything else.\r\n        Permissions permissions = new Permissions();\r\n        permissions.add(new PropertyPermission(\"foo\", \"read\"));\r\n\r\n        // Before we evaluate the script, we confine the permissions on all classes loaded through the\r\n        // ScriptEvaluator's class loader. Each *Evaluator creates a new class loader exclusively for loading the\r\n        // classes it generates.\r\n        Sandbox.confine(se.getMethod().getDeclaringClass().getClassLoader(), permissions);\r\n\r\n        // Finally we evaluate the script. Getting system property 'foo' will succeed, and getting 'bar' will\r\n        // throw an InvocationTargetException caused by\r\n        //    java.security.AccessControlException: access denied (java.util.PropertyPermission bar read)\r\n        // Et voila!\r\n        se.evaluate(null);\r\n    }\r\n}\r\n```\r\n\r\n\"de.unkrig.commons.lang.security.Sandbox\" is available on \"de.unkrig.commons\".\r\n\r\n### Debugging\r\n\r\nThe generated classes can be debugged interactively, even though they were created on-the-fly.\r\n\r\nAll that needs to be done is set two system properties, e.g. when starting the JVM:\r\n\r\n```shell\r\n$ java -Dorg.codehaus.janino.source_debugging.enable=true -Dorg.codehaus.janino.source_debugging.dir=C:\\tmp\r\n```\r\n\r\n(The second property is optional; if not set, then the temporary files will be created in the default temporary-file directory.)\r\n\r\nWhen JANINO scans an expression, script, class body or compilation unit, it stores a copy of the source code in a temporary file which the debugger accesses through its source path. (The temporary file will be deleted when the JVM terminates.)\r\n\r\nThen when you debug your program\r\n\r\n![Debugging](janino-debugging.jpg)\r\n\r\n, you can step right into the generated code\r\n\r\n![Debugging](janino-debugging2.jpg)\r\n\r\n, and debug it:\r\n\r\n![Debugging](janino-debugging3.jpg)\r\n\r\nAs you can see, you can even inspect and modify fields and variables - everything your debugger supports.\r\n\r\n## Contact\r\n\r\n### Reporting bugs\r\n\r\nIf you think you have found a bug in Janino, proceed as follows:\r\n\r\n* If it is a compilation problem, verify that ORACLE's JavaTM compiler JAVAC also believes it is one.\r\n\r\n* Try to isolate the problem. Don't send me huge source files; attempt, if at all possible, to reproduce the problem with a JUNIT unit test, or with the ExpressionDemo/ScriptDemo/ClassBodyDemo command-line tools.\r\n\r\n* Sign up at SOURCEFORGE and create a bug ticket [there](https://sourceforge.net/p/janino/bugs/). Please state which version of Janino you were using, what you did, what you expected to happen and what actually happened.\r\n\r\n### Requesting support\r\n\r\nIf you require support, [this](https://sourceforge.net/p/janino/support-requests/) is the place to ask for it.\r\n\r\n### Requesting new features\r\n\r\nFeel free to submit feature requests [here](https://sourceforge.net/p/janino/feature-requests/).\r\n\r\n### Feedback\r\n\r\nI appreciate your feedback. Let me know how you want to utilize Janino, if you find it useful, or why you cannot use it for your project.\r\n\r\n### Mailing List\r\n\r\nThere is a mailing list \"janino-users\", which is used for general discussions and version announcements. You can subscribe to it and browse the archive [here](https://sourceforge.net/p/janino/mailman/janino-users/).\r\n\r\nIMPORTANT: For bug reports, support requests and feature requests, please use the ticket system as described above. Tracking issues by e-mail is a nightmare!\r\n\r\n## Developers\r\n\r\n### Source Code Repository\r\n\r\nThe JANINO code repository is [here](https://github.com/janino-compiler/janino). You have to check out the following ECLIPSE projects:\r\n\r\n* [commons-compiler](https://github.com/janino-compiler/janino/tree/master/commons-compiler)\r\n* [commons-compiler-jdk](https://github.com/janino-compiler/janino/tree/master/commons-compiler-jdk)\r\n* [janino](https://github.com/janino-compiler/janino/tree/master/janino)\r\n\r\nAnd also from SOURCEFORGE SVN:\r\n\r\n* [de.unkrig.commons.nullanalysis]https://svn.code.sf.net/p/loggifier/code/trunk/de.unkrig.commons.nullanalysis)\r\n\r\nOptional:\r\n\r\n* [commons-compiler-tests](https://github.com/janino-compiler/janino/tree/master/commons-compiler-tests)\r\n* [de.unkrig.jdisasm](https://github.com/janino-compiler/janino/tree/master/de.unkrig.jdisasm)\r\n* [de.unkrig.jdisasm_test](https://github.com/janino-compiler/janino/tree/master/de.unkrig.jdisasm_test)\r\n* [janino-dist](https://github.com/janino-compiler/janino/tree/master/janino-dist)\r\n* [janino-tests](https://github.com/janino-compiler/janino/tree/master/janino-tests)\r\n\r\nIf these ECLIPSE projects appear without any errors, then you can build the JAR files, the source ZIP files and the JAVADOC by executing the \"janino-dist build.xml build\" external tool configuration.\r\n\r\n### Contributing\r\n\r\nIf you want to contribute, turn to me: arno att unkrig dott de. Any support is welcome, be it bug reports, feature requests, documentation reviews or other work. Help building a better world with JANINO!\r\n\r\n### Version Control\r\n\r\n* Be careful when committing. Know SVN; know what you're doing. Commit only code that compiles and works.\r\n\r\n* Never commit into the main branch; this is the despot's domain!\r\n\r\n* Discuss with the despot before creating branches.\r\n\r\n* Write unit tests for everything you code. \"tests/src/EvaluatorTests.java\" is a good starting point.\r\n\r\n* Use the existing unit tests to verify that you didn't break anything - run \"AllTests\".\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}